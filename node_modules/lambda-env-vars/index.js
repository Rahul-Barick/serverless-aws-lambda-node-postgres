'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line
var AWS = require('aws-sdk');

var decryptedVariables = {};
var s3StoredVariables = {};

var LambdaEnvVars = function () {
  /**
   * Injects the node process API and sets the isntance of AWS KMS.
   *
   * @param {Object} params
   * Default params to be sent with each request.
   *
   * @param {string} params.location
   * Location of the environment variables. ENUM ('lambdaConfig', 's3')
   *
   * @param {Object} params.s3Config
   * Config used to get the an env var file from S3.
   *
   * @param {string} params.s3Config.bucketName
   * @param {string} params.s3Config.fileName
   *
   * @return {Object}
   * Instance of EnvVars.
   */
  function LambdaEnvVars() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, LambdaEnvVars);

    this.defaultParams = {
      location: 'lambdaConfig',
      s3Config: {}
    };

    this.defaultParams = (0, _assign2.default)(this.defaultParams, params);
    this.process = process;
    this.kms = new AWS.KMS({ apiVersion: '2014-11-01' });
    this.s3 = new AWS.S3({ apiVersion: '2006-03-01' });
    this.decryptedVariables = decryptedVariables;
    this.s3Vars = s3StoredVariables;
    this.availableStoreLocations = ['s3', 'lambdaConfig'];
  }

  /**
   * Returns a variable stored simply in the process.env node API.
   *
   * @param {string} variableName
   * The key of the environment variable to fetch.
   *
   * @return {string}
   * Returns the environment variable if it is set, else an empty string.
   */


  (0, _createClass3.default)(LambdaEnvVars, [{
    key: 'getDefaultDecryptedValue',
    value: function getDefaultDecryptedValue() {
      var variableName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      return this.process.env[variableName] || '';
    }

    /**
     * Gets the decrypted value of an encrypted variable. Will check to see if this has been decrypted
     * already by checking the in-memory/global cariable cache of decrypted variables.
     *
     * @param {string} variableName
     * The key in process.env to which the variable is stored under.
     *
     * @param {Object} params
     * Params to state where the environment variable is stored.
     *
     * @param {string} params.location
     * Location of the environment variables. ENUM ('lambdaConfig', 's3')
     *
     * @param {Object} params.s3Config
     * Config used to get the an env var file from S3.
     *
     * @param {string} params.s3Config.bucketName
     * @param {string} params.s3Config.fileName
     *
     * @return {Promise}
     * A promise that resolves the value if it is available, else an empty string if it not set in
     * the node environment variables, or a rejected promise if KMS couldn't decypt the value.
     */

  }, {
    key: 'getCustomDecryptedValue',
    value: function getCustomDecryptedValue() {
      var _this = this;

      var variableName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.buildParams(params).then(function (builtParams) {
        if (builtParams.location === 's3') {
          return _this.getVarFromS3File(variableName, builtParams.s3Config);
        }

        if (_this.decryptedVariables[variableName]) {
          return _promise2.default.resolve(_this.decryptedVariables[variableName]);
        }

        if (variableName === '' || !_this.process.env[variableName]) {
          return _promise2.default.resolve('');
        }

        return _this.decryptVariable(variableName).then(function (result) {
          return _this.setEncryptedVariable(variableName, result);
        });
      });
    }

    /**
     * Gets an env var from a file within S3.
     *
     * @param {string} variableName
     * The key in process.env to which the variable is stored under.
     *
     * @param {Object} s3Config
     * Config on filename, bucket name etc.
     *
     * @return {Promise}
     * Promise that resolves the variable name
     */

  }, {
    key: 'getVarFromS3File',
    value: function getVarFromS3File(variableName, s3Config) {
      var _this2 = this;

      var fileKey = s3Config.bucketName + s3Config.fileName;

      if (this.s3Vars[fileKey]) {
        return _promise2.default.resolve(this.s3Vars[fileKey][variableName]);
      }

      var s3Params = {
        Key: s3Config.fileName,
        Bucket: s3Config.bucketName
      };

      return this.s3.getObject(s3Params).promise().then(function (result) {
        return JSON.parse(result.Body.toString());
      }).then(function (s3File) {
        _this2.s3Vars[fileKey] = s3File;
        return _this2.s3Vars[fileKey][variableName];
      }).catch(function () {
        var errorMessage = 'Could not successfully load variable from s3 file. Please make sure the file is valid JSON and that the lambda function has the sufficient role to get the S3 file.';
        throw new Error(errorMessage);
      });
    }

    /**
     * Validates the parameters that should state where to get the environment variables from. Returns
     * the built parameters.
     *
     * @param {Object} params
     * Object containing the parameters.
     *
     * @param {string} params.location
     * Location of the environment variables. ENUM ('lambdaConfig', 's3')
     *
     * @return {Promise}
     * Resolves the params for the call or rejects an error.
     */

  }, {
    key: 'buildParams',
    value: function buildParams() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var callParams = (0, _assign2.default)({}, this.defaultParams, params);

      if (this.availableStoreLocations.indexOf(callParams.location) < 0) {
        var availableOptions = this.availableStoreLocations.join(', ');
        var errorMessage = 'Field \'location\' must be one of the following ' + availableOptions;
        return _promise2.default.reject(new Error(errorMessage));
      }

      if (params.location === 's3' && (!params.s3Config || !params.s3Config.bucketName || !params.s3Config.fileName)) {
        var _errorMessage = 's3Config.bucketName and s3Config.fileName are required when location is \'s3\'';
        return _promise2.default.reject(new Error(_errorMessage));
      }

      return _promise2.default.resolve(callParams);
    }

    /**
     * Decrypts a list of environment variables and returns them in an object where the keys are the
     * env variable keys and the values are the decrypted values.
     *
     * @param {string[]} variableNames
     * An array of environment variable keys to decrypt.
     *
     * @param {Object} params
     * Params to state where the environment variable is stored.
     *
     * @return {Promise}
     * A promise that resolves an object containing the decrypted values where the keys are the items
     * specified in the params variableNames.
     */

  }, {
    key: 'getCustomDecryptedValueList',
    value: function getCustomDecryptedValueList() {
      var _this3 = this;

      var variableNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var decryptedVariablesObject = {};

      var decryptedValuePromiseList = variableNames.map(function (envVar) {
        return _this3.getCustomDecryptedValue(envVar, params).then(function (decryptedValue) {
          decryptedVariablesObject[envVar] = decryptedValue;
        });
      });

      return _promise2.default.all(decryptedValuePromiseList).then(function () {
        return decryptedVariablesObject;
      });
    }

    /**
     * Sets the environment variable to the decryptedVariable object so it is cached per container.
     *
     * @param {string} variableName
     * The key in process.env to which the variable is stored under.
     *
     * @param {mixed} variableName
     * The data to store in decryptedVariables.
     *
     * @return {string}
     * Returns the variable passed in for the purpose of promise chaining.
     */

  }, {
    key: 'setEncryptedVariable',
    value: function setEncryptedVariable(variableName, value) {
      this.decryptedVariables[variableName] = value;
      return value;
    }

    /**
     * Uses AWS KMS to decrypt the variable, which is then resolved in the promise return value.
     *
     * @param {string} variableKey
     * The variable key to decrypt.
     *
     * @return {Promise}
     * Resolves a promise that resolves the decrypted value or resolves.
     */

  }, {
    key: 'decryptVariable',
    value: function decryptVariable(variableKey) {
      var encrypted = this.process.env[variableKey];
      return this.kms.decrypt({ CiphertextBlob: new Buffer(encrypted, 'base64') }).promise().then(function (data) {
        return data.Plaintext.toString('ascii');
      });
    }
  }]);
  return LambdaEnvVars;
}();

exports.default = LambdaEnvVars;